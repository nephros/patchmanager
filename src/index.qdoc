/*!

  \page index.html

  \indexpage Index
  \title Patchmanager Documentation
  \startpage Patchmanager Overview

  \section2 Manual List
  \list
  \li \l {Patchmanager Overview}
  \li \l {Patchmanager Daemon}
  \li \l {Patchmanager GUI Application}
  \li \l {Patchmanager Startup Dialog}
  \endlist

  \section2 Classes
  \generatelist annotatedclasses
  \section2 QML Types
  \generatelist qmltypesbymodule org.SfietKonstantin.patchmanager
*/

/****** Overview page *******/
/*!
  \title Patchmanager Overview

  \page overview.html

  So the current mode of operation of Patchmanager is something like this:

  \section1 Operation Flow

  \section2 1. A Patch is "activated"

  When a user activates a patch via the App, a signal is sent to the daemon.

  The daemon will then:

  For each file the patch manipulates, a copy of the original file is put into
  a cache dir in \c /tmp, and the changes are applied there instead of on the
  original file.

  If there are paths or files involved in the patch which do not exist yet
  in the filesystem, they will be created in the cache dir, and a symlink
  pointing to them is placed in the original filesystem.

  \section2 2. A patched application is launched.

  Through library preloading, the \c libpreloadpatchmanager.so library is
  injected into the launching binary.

  \section2 3. The Preload Library:

  Intercepts calls to \c open()  or (\c open64()), analyzes which files
  the call was meant to open asks the patchmanager daemon (via socket) whether
  it knows of a patched version.

  If yes, the daemon will return a path to its cachedir, and the library
  redirects the call to that file instead of the original. Otherwise, the
  \c{open()} is executed on the original file.

  Certain paths are blacklisted for these operations to reduce the risk of
  critical services, or PM itself, choking on these redirections.

  \e{to be continued...}

*/

